all: clean build cov docs-full build-release

build:
	cargo build --workspace

test:
	cargo test --workspace --no-fail-fast

build-release:
	cargo build --workspace --release

clean:
	cargo clean

docs:
	cargo doc --workspace --no-deps

docs-full:
	cargo doc --workspace

fmt:
	cargo fmt --all

fmt-check:
	cargo fmt --all --check

clippy:
	cargo clippy --all-targets --no-deps --fix

clippy-check:
	cargo clippy --all-targets --no-deps

qlty-install:
	curl https://qlty.sh | bash
	qlty init

qlty: fmt clippy
	qlty check --filter clippy --fix

qlty-check:
	qlty check --filter clippy
	qlty smells ./ot-tools-*/

DOCKER_LOCAL_IMAGE_NAME="ot-tools"

docker:
	docker build -t "${DOCKER_LOCAL_IMAGE_NAME}" -f ./Dockerfile .

docker-uncached:
	docker build -t "${DOCKER_LOCAL_IMAGE_NAME}" --no-cache -f ./Dockerfile .

# should only be run on gitlab CI during release
docker-release-glab: docker-uncached
	@[ "${CI_REGISTRY_IMAGE}" ] || ( echo ">> CI_REGISTRY_IMAGE is not set"; exit 1 )
	@[ "${CI_COMMIT_TAG}" ] || ( echo ">> CI_COMMIT_TAG is not set"; exit 1 )
	docker tag "${DOCKER_LOCAL_IMAGE_NAME}" "${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_SLUG}"
	docker tag "${DOCKER_LOCAL_IMAGE_NAME}" "${CI_REGISTRY_IMAGE}:latest"
	docker push "${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_SLUG}"
	docker push "${CI_REGISTRY_IMAGE}:latest"

# should only be run on github CI during release
docker-release-ghub: docker-uncached
	echo "todo"

cov-install:
	cargo install cargo-tarpaulin

cov: cov-install
	cargo tarpaulin --workspace --exclude ot-tools-py --exclude ot-tools-derive

cov-xml: cov-install
	cargo tarpaulin -o xml --workspace --exclude ot-tools-py --exclude ot-tools-derive

cov-junit: cov-install
	cargo +nightly install junitify
	cargo +nightly test -- --format=json -Z unstable-options --report-time | junitify --out test-results

publish-derive:
	@[ "${CARGO_PUBLISH_TOKEN}" ] || ( echo ">> CARGO_PUBLISH_TOKEN is not set"; exit 1 )
	cargo publish --package "ot-tools-derive" --dry-run --token ${CARGO_PUBLISH_TOKEN}

publish-io:
	@[ "${CARGO_PUBLISH_TOKEN}" ] || ( echo ">> CARGO_PUBLISH_TOKEN is not set"; exit 1 )
	cargo publish --package "ot-tools-io" --dry-run --token ${CARGO_PUBLISH_TOKEN}

publish-ops:
	@[ "${CARGO_PUBLISH_TOKEN}" ] || ( echo ">> CARGO_PUBLISH_TOKEN is not set"; exit 1 )
	cargo publish --package "ot-tools-ops" --dry-run --token ${CARGO_PUBLISH_TOKEN}

PYTHON_EXT_PACKAGE_NAME="ot-tools-py"
PYTHON_EXT_MODULE_NAME="ot_tools_py"

py-setup:
	python3 -m venv ./${PYTHON_EXT_PACKAGE_NAME}/venv/
	./${PYTHON_EXT_PACKAGE_NAME}/venv/bin/python3 -m pip install maturin

# HACK: need this 'hidden' build step as otherwise the wildcard instruction
# doesn't work reliably (make doesn't seem to be aware of the file that's just
# been generated in the line above, instead it's only aware of the wheel if it's
# been generated by a previous execution of make py-build)
.py-build-mat: py-setup
	./${PYTHON_EXT_PACKAGE_NAME}/venv/bin/maturin build --manifest-path ./${PYTHON_EXT_PACKAGE_NAME}/Cargo.toml

py-build: .py-build-mat
	./${PYTHON_EXT_PACKAGE_NAME}/venv/bin/python3 -m pip install --force-reinstall $(wildcard ./target/wheels/ot_tools_py*)

py-smoke: py-build
	./${PYTHON_EXT_PACKAGE_NAME}/venv/bin/python3 -Bc "import ${PYTHON_EXT_MODULE_NAME}, json; keys = json.loads(${PYTHON_EXT_MODULE_NAME}.binfiles.bank_file_to_json(\"./data/tests/blank-project/bank01.work\")).keys(); print('arrange:', keys)"
	./${PYTHON_EXT_PACKAGE_NAME}/venv/bin/python3 -Bc "import ${PYTHON_EXT_MODULE_NAME}, json; keys = json.loads(${PYTHON_EXT_MODULE_NAME}.binfiles.arrangement_file_to_json(\"./data/tests/blank-project/arr01.work\")).keys(); print('bank:', keys)"
	./${PYTHON_EXT_PACKAGE_NAME}/venv/bin/python3 -Bc "import ${PYTHON_EXT_MODULE_NAME}, json; keys = json.loads(${PYTHON_EXT_MODULE_NAME}.binfiles.project_file_to_json(\"./data/tests/blank-project/project.work\")).keys(); print('project:', keys)"
	./${PYTHON_EXT_PACKAGE_NAME}/venv/bin/python3 -Bc "import ${PYTHON_EXT_MODULE_NAME}, json; keys = json.loads(${PYTHON_EXT_MODULE_NAME}.binfiles.sample_attributes_file_to_json(\"./data/tests/misc/pair.ot\")).keys(); print('sample:', keys)"

gen-examples-human-readable:
	echo "Generating YAML example files ..."
	rm -rf ./examples/human-readable/yaml
	mkdir -p ./examples/human-readable/yaml
	cargo r bin-files bin-to-human bank data/tests/blank-project/bank01.work yaml ./examples/human-readable/yaml/bank01.yaml >/dev/null 2>&1
	cargo r bin-files bin-to-human project data/tests/blank-project/project.work yaml ./examples/human-readable/yaml/project.yaml >/dev/null 2>&1
	cargo r bin-files bin-to-human arrangement data/tests/blank-project/arr01.work yaml ./examples/human-readable/yaml/arr01.yaml >/dev/null 2>&1
	echo "Generating JSON example files ..."
	rm -rf ./examples/human-readable/json
	mkdir -p ./examples/human-readable/json
	cargo r bin-files bin-to-human bank data/tests/blank-project/bank01.work json ./examples/human-readable/json/bank01.json >/dev/null 2>&1
	cargo r bin-files bin-to-human project data/tests/blank-project/project.work json ./examples/human-readable/json/project.json >/dev/null 2>&1
	cargo r bin-files bin-to-human arrangement data/tests/blank-project/arr01.work json ./examples/human-readable/json/arr01.json >/dev/null 2>&1
	echo "Done."
